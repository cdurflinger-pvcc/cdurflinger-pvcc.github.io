<!DOCTYPE html>

<!--Name: Cody Durflinger

	PROG PURPOSE: This file is for Chapter 5 and associated vocab
-->
<html lang="en">
<head>
	<title>Chapter 5: Programming Algorithms & Software Testing</title>
</head>
<body style="color:#deb17b;background-color:c04944;font-family:arial,calibri,verdana,sans-serif;">
<h1>Chapter 5</h1>
<h2>Phases of computer program development:</h2>
<h3>
<ul>
	<li>Phase 1: Understand the Problem</li>
	<li>Phase 2: Design an algorrithm to solve the problem</li>
	<li>Phase 3: Write the program code in appropriate language based on the algorithm</li>
	<li>Phase 4: Enter the program and save</li>
	<li>Phase 5: Execute the program</li>
	<li>Phase 6: Test the program, find errors and debug, then restart</li>
	<li>Phase 7: Document and evaluate the program</li>
</ul>
</h3>
<h2>Programming Structures</h2>
<h3>
<ul>
	<li>Sequential structure: Top-down execution</li>
	<li>Decision structures: if/then/else</li>
	<li>Iterative (Looping)</li>
		<li>while loop: continue looping as long as something is true</li>
		<li>repeat/until loop: continue looping until something is true</li>
		<li>for loop: loop a given number of times</li>
	<li>Recursive structures:</li>
		<li>Repeat a set of instructions as a subtask of itself</li>
		<li>Repetition continues until:</li>
			<li>degerative case, which is a termination condition, is met</li>
			<li>(degerative case is also called a "base case")</li>
</ul>
</h3>
<h2>Two classic programming/database probelms</h2>
<h3>
	<ul>
	<li>Sorting: Descending order/Ascending order</li>
		<li>Sorting numbers</li>
		<li>Sorting strings (in accordance with ASCII values)</li>
	<li>Searching: find specific data that meet a certain criteria</li>
		<li>In database:</li>
			<li>Filters: temporary search</li>
			<li>Queries: search criteria are saved so they don't have to be recreated</li>
	<li>Two popular search techniques</li>
		<li>Sequential search: search from top to bottom or bottom to top, one item at a time</li>
		<li>Binary search:</li>
			<li>only works if data is SORTED first</li>
			<li>start in the middle,then fo to half of that, etc</li>
</ul>
</h3>
<h2>Two classic program goals:</h2>
<h3>
	<ul>	
	<li>Efficiency: Program takes minimal time and/or resources</li>
	<li>Correctness: Programs runs in expected ways and works for all expected conditions</li>
	</ul>
</h3>
<h2>Software testing and verification</h2>
<h3>Kinds of tests</h3>
<h3>
<ul>
	<li>Acceptance testing:</li>
		<li> Verifying whether the whole system works as intended</li>
	<li>Intergration testing:</li>
		<li>Ensuring that software components or functions operate together</li>
	<li>Unit testing:</li>
		<li>Validating that each software unit performs as expected. A unit is the smallest testable component of an application</li>
	<li>Functional testing:</li>
		<li>Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions</li>
	<li>Performance testing:</li>
		<li>Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions</li>
	<li>Regression testing:</li>
		<li>Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</li>
	<li>Stress testing:</li>
		<li>Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing</li>
	<li>Usability testing:</li>
		<li>Validating how well a customer can use a system or web application to complete a task.</li>
</ul>
</h3>
<h3>Software testing is done to detect:</h3>
	<li>Architectural flaws</li>
		<li></li>
	<li>Poor design decisions</li>
		<li></li>
	<li>Invaild or incorrect functionality</li>
		<li></li>
	<li>Security vulnerabilities</li>
		<li></li>
	<li>Scalability issues</li>
</ul>
</h3>
<h3>Testing best practices:</h3>
	<li>Continuois testing</li>
		<li>automated testing of software so it can be validated for realistic environments.</li>
	<li>Configuration management</li>
		<li></li>
	<li>Service virtualization</li>
		<li></li>
	<li>Defect or "bug tracking"</li>
		<li></li>
	<li>Metrics and reporting</li>
		<li></li>
</ul>
</h3>



